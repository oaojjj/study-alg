#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "pos.h"
#include "stackADT.h"

#define MAX 100
#define PATH 0 // 지나갈 수 있는 위치
#define WALL 1 // 벽
#define VISITED 2 // 이미 방문한 위치
#define BACKTRACKED 3 // 방문했던 위치
#define EXIT 9 // 출구

int maze[MAX][MAX];
int n; // 미로크기 파일에서 맨 처음에 제공 #if n=3,, 3x3미로
int offset[4][2];

void read_maze();
void print_maze();
bool movealbe(Position cur, int dir);

int main() {
	read_maze();

	Stack s = create(); 
	Position cur;
	cur.x = 0;
	cur.y = 0;

	int init_dir = 0; // 어떤 위치에 도착했을 때 처음으로 시도하는 이동 방향
	while (1) {
		maze[cur.y][cur.x] = VISITED;
		print_maze();
		printf("\n\n");

		bool forwarded = false;
		for (int dir = init_dir; dir < 4; dir++) { // 북:0, 동:1, 남:2, 서:3
			if (movealbe(cur, dir)) {
				push(s, dir); // 스택에 현재 위치 대신 이동하는 방향을 push
				cur = move_to(cur, dir);
				forwarded = true;
				init_dir = 0;
				break;
			}
		}

		if (!forwarded) { // 어떤곳도 방문하지 못할 경우
			maze[cur.y][cur.x] = BACKTRACKED;
			if (is_empty(s)) {
				printf("no path exists\n");
				break;
			}

			int d = pop(s);
			cur = move_to(cur, (d + 2) % 4); // if top is 2 ,,,(2+2)%4=0
			
			init_dir = d + 1; // 되돌아 온곳에서 방문하는 다음 위치
		}

	}
	print_maze();
}

void read_maze() {
	FILE*fp = fopen("maze.txt","r");

	if (fp == NULL) {
		printf("error read maze\n");
		return;
	}
	int i, j;
	fscanf(fp, "%d", &n);
	for(int i=0;i<n;i++){
		for (int j = 0; j < n; j++) {
			fscanf(fp, "%d", &maze[i][j]);
		}
	}
	fclose(fp);
}

void print_maze() {
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			printf("%3d", maze[i][j]);
		}
		printf("\n");
	}
}


bool movealbe(Position cur, int dir) {
	cur.x += offset[dir][1];
	cur.y += offset[dir][0];
	if ((cur.x < 0 || cur.x >= n) || (cur.y<0 || cur.y>=n)) // 이동할 위치가 미로를 벗어나면 안된다.
		return false;
	if (maze[cur.y][cur.x] == PATH) // 이동할 위치가 PATH라면 이동할 수 있다.
		return true;
	if (maze[cur.y][cur.x] == EXIT) {
		printf("found the exit\n");
		exit(0);
	}
		
	return false;
}
